## This file must *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
#Tue Feb 21 18:13:08 EET 2023
telemetry.addData("Corectat=cu mers",dist);
if(dist-corectieBaseBratMM=>0){
clawRight.setPosition(clawRightClose);=
dist2_citiri[listSize]=(distanceSensor2.getDistance(DistanceUnit.MM));
}else{=
lift.setTargetPosition(0);=
if(dist=<\= sensorretard -off){
445,=
drive.setWeightedDrivePower(new=Pose2d(0,0,0));
else=if(cameraRecognition.detector.caz \=\= PipeLineDetector.Status.ROSU2){
try{=
clawRotate.setPosition(0.372);=//0.362
Wait(10000);=
if(x=\= -1) {
brat.setDirection(DcMotorSimple.Direction.REVERSE);=
if(cycle=>\=3){
double=y\= p1.getY() - p2.getY();
Thread.sleep(ms);=
)=
corectieDirectieTemp=-corectieDirectieTemp;
lift.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);=
cdist=cdist/terms;
0=
1=pentru stanga
);=
telemetry.addData("detected",=caz);
Pose2d=current_pos \= drive.getPoseEstimate();
Servo=s \= hardwareMap.get(Servo.class,servo);
lift=hardwareMap.get(DcMotor.class,"lift");
clawRotate.setPosition(0.514);=
drive=new SampleMecanumDrive(hardwareMap);
lift.setPower(1);=
corectieVitezaRot=* corectieDirectieTemp
Wait(500);=
s.setPosition(target);=
*/=
clawRotate=hardwareMap.get(Servo.class,"clawRotate");
//HardwareTesterInterpreter.initHWI(this,hardwareMap,telemetry,drive);=
brat.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);=
brat.setTargetPosition(0);=
long=t2 \= System.currentTimeMillis();
corectieViteza*1,=
@Autonomous(name="Test Corectie", group\="Linear Opmode")
lift.setTargetPosition(1100);=
distanceSensor=hardwareMap.get(DistanceSensor.class,"distanceSensor");
startTime=t2;
telemetry.addData("Y=OLD",oldPose.getY());
telemetry.addData("X=NOW",current_pos.getY());
oldDirection=corectieDirectieTemp;
};=
drive.trajectoryBuilder(new=Pose2d(0,0,Math.toRadians(0)),false)
.build();=
-corectieViteza*1,=
corectieTimeoutTemp=+\= 90;
cameraRecognition=new CameraRecognition(hardwareMap,telemetry,"red");
clawLeft.setPosition(clawLeftClose);=
clawLeft=hardwareMap.get(Servo.class,"clawLeft");
if(cameraRecognition.detector.caz=\= PipeLineDetector.Status.VERDE1){
off=0;
Thread=th \= new Thread() {
for(int=j\=0;j<\=listSize;j++){
terms++;=
return;=
.lineTo(new=Vector2d(31,1))
SampleMecanumDrive=drive;
while(\!opModeIsActive()=&& \!isStopRequested()){
Wait(10);=
.splineToSplineHeading(new=Pose2d(preloadX, preloadY, Math.toRadians(preloadRot)),Math.toRadians(preloadTg))
}=
first=//drive.trajectoryBuilder(new Pose2d(0,0,Math.toRadians(0)))
return=Math.sqrt(x*x+y*y) * 2.54;
//dist=distanceSensor.getDistance(DistanceUnit.MM);
dist1_citiri[j=- 1] \= dist1_citiri[j];
telemetry.addData("Am=mers",m);
780,=
main();=
telemetry.update();=
telemetry.addData("Distanta=de fail",dist);
c.brat=bratUp;
dist=c.dist - m;
clawRight=hardwareMap.get(Servo.class,"clawRight");
615,=
Wait(5000);=
while=(dist >\=sensorretard-off) {
320,=
drive.setWeightedDrivePower(=
DistanceSensor=distanceSensor,distanceSensor2;
@Config=
dist1_citiri[listSize]=(distanceSensor.getDistance(DistanceUnit.MM));
Trajectory=first;
//.splineToSplineHeading(new=Pose2d(preloadX, preloadY, Math.toRadians(preloadRot)),Math.toRadians(preloadTg)).build();
if(listSize=< cycleMed-1)
lift.setTargetPosition(100);=
DcMotor=dc \= hardwareMap.get(DcMotor.class,motor);
cameraRecognition.start(1);=
@Override=
new=Pose2d(
clawLeft.setPosition(clawLeftOpen);=
package=org.firstinspires.ftc.teamcode.sezon2023;
void=Wait(int ms){
-1=pentru dreapta
listSize++;=
corectieDirectie=1;
break;=
brat=hardwareMap.get(DcMotor.class,"brat");
}catch=(Exception ex){
telemetry.addData("Facem=cazul",caz);
brat.setMode(DcMotor.RunMode.RUN_TO_POSITION);=
dc.setTargetPosition(target);=
final=int x \= timeout;
//.lineTo(new=Vector2d(fX,fY))
cameraRecognition.initCamera();=
waitForStart=();
private=void main(){
cycle++;=
import=org.firstinspires.ftc.teamcode.sezon2022.PipeLineDetector;
dc.setMode(DcMotor.RunMode.RUN_TO_POSITION);=
if(\!opModeIsActive()=|| isStopRequested())
for=(int j \= 1; j < cycleMed; j++) {
CameraRecognition=cameraRecognition;
th.start();=
distanceSensor2=hardwareMap.get(DistanceSensor.class,"distanceSensor2");
sdk.dir=C\:\\Users\\Ionut\\AppData\\Local\\Android\\Sdk
public=int brat;
cameraRecognition.stop();=
lift.setMode(DcMotor.RunMode.RUN_TO_POSITION);=
if(ccc.dist=<1){
/*=
drive.update();=
caz=3;
if(t2=- startTimeReal >\=2000){
//=return 0;
clawRight.setPosition(clawRightOpen);=
lift.setTargetPosition(lift.getCurrentPosition());=
bratTarget=+\= (int)Math.round((dist-corectieBaseBratMM)/10.0 * corectieMultiBratMinus);
CorectieOutput=ccc \= corectie();
int=x \= corectie2(0,ccc);
Wait(x);=
double[]=dist2_citiri \= new double[5];
c.dist=cdist;
brat.setTargetPosition(bratUp);=
0,=
dist2=dist2/listSize;
brat.setPower(1);=
